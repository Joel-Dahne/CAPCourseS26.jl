var documenterSearchIndex = {"docs":
[{"location":"week-9/#Week-9-TODO","page":"Week 9 - TODO","title":"Week 9 - TODO","text":"","category":"section"},{"location":"week-2/#Week-2-TODO","page":"Week 2 - TODO","title":"Week 2 - TODO","text":"","category":"section"},{"location":"week-15/#Week-15-TODO","page":"Week 15 - TODO","title":"Week 15 - TODO","text":"","category":"section"},{"location":"week-8/#Week-8-TODO","page":"Week 8 - TODO","title":"Week 8 - TODO","text":"","category":"section"},{"location":"week-3/#Week-3-TODO","page":"Week 3 - TODO","title":"Week 3 - TODO","text":"","category":"section"},{"location":"week-1-lab/#Week-1-Lab","page":"Week 1 Lab","title":"Week 1 Lab","text":"","category":"section"},{"location":"week-4/#Week-4-TODO","page":"Week 4 - TODO","title":"Week 4 - TODO","text":"","category":"section"},{"location":"week-13/#Week-13-TODO","page":"Week 13 - TODO","title":"Week 13 - TODO","text":"","category":"section"},{"location":"week-14/#Week-14-TODO","page":"Week 14 - TODO","title":"Week 14 - TODO","text":"","category":"section"},{"location":"week-1-lecture-1/#Week-1-Lecture-1-Introduction-to-computer-assisted-proofs","page":"Week 1 Lecture 1 - Introduction to computer-assisted proofs","title":"Week 1 Lecture 1 - Introduction to computer-assisted proofs","text":"The main goal of this first lecture is to give you an idea of what to expect about the course. We will take a look at the structure of the course and an overview of the content we will cover.\n\nThe course consists of 15 weeks which we will split into 3 different parts. The 3 parts are\n\nIntroduction to computer-assisted proofs (≈ Week 1-4)\nIntroduction to rigorous numerics (≈ Week 5-10)\nComputer-assisted proofs in practice (≈ Week 11-15)\n\nEach week will follow roughly the same pattern. The Monday and Wednesday sessions will be lectures where I present material, the Friday session will be a computer lab where you get to try out what we have discussed during the lectures.","category":"section"},{"location":"week-1-lecture-1/#Computer-labs","page":"Week 1 Lecture 1 - Introduction to computer-assisted proofs","title":"Computer labs","text":"For the computer labs we will make use of Julia. We will talk more about Julia during the first computer lab on Friday. A very brief description is that the Julia language is designed for high performance scientific computing. Version 1.0 was released in 2018, so it is a relatively young language compared to for example C, Fortran, Python and Matlab.\n\nThe main goal for the Friday session is to make sure that you are all able to install Julia and get it up and running. In general the course will not assume familiarity with Julia, it should hopefully be possible for you to pick it up as we go.\n\nThis web page you are reading now is generated using Julia. In fact, the repository associated with this course is structured as a Julia package. We will talk more about this later on.","category":"section"},{"location":"week-1-lecture-1/#Part-1:-Introduction-to-computer-assisted-proofs","page":"Week 1 Lecture 1 - Introduction to computer-assisted proofs","title":"Part 1: Introduction to computer-assisted proofs","text":"What is a computer-assisted proof? This is not an obvious question and the answer will depend on who you ask. For the purposes of this course there will be an answer to this question, but getting there requires a bit of background.\n\nLet us start by considering a slightly different question, what is computer-assisted mathematics? In this case it could be more or less anything that involves a computer. Examples could include\n\nNumerical simulations, such as solving some PDE using numerical methods or computing images of the Cantor set.\nAnalysing data, in particular in applied mathematics you might have actual datasets you want to analyse. But you could also analyse large databases of knots.\nSymbolical computations, for example computing integrals or handling very large expressions using e.g. Sage, WolframAlpha, Mathematica or Maple.\nUsing LLMs or other similar tools for solving mathematical problems or writing manuscripts.\n\nMore or less anything where you make use of the computer to help you in your mathematical research. One could even include things like:\n\nUsing Arxiv to find articles.\nWriting your article in LaTeX.\nCommunicating with your collaborators using email.\n\nWe are however interested in something slightly different, not computer-assisted mathematics but computer-assisted proofs. The name implies that it should involve proofs, but that is true for most of mathematics so doesn't restrict us much. We will however mean something more specific, for our purposes a computer-assisted proof is a mathematical proof of some mathematical statement which requires a computer to verify. The key here is that the computer is involved in the verification, not only the construction of the proof. Some things which are not computer-assisted proofs with this definition are:\n\nUsing an LLM to generate a human readable mathematical proof.\nUsing numerical simulations to generate an hypothesis which is then proved using pen and paper.\nUsing symbolical computations to compute a nasty integral, where the answer can be verified by hand.\n\nWhat would be an example of a computer-assisted proof then? What does it mean to use a computer to verify a proof? The prototypical example would be something that requires a lot of calculations. Showing that the fifth decimal in pi is 9 you could do by hand, showing that the millionth decimal is 1 you probably couldn't. There is, however, nothing fundamentally different between computing the fifth decimal or the millionth decimal. In theory you could compute the millionth decimal by hand, it would just take you a veeery long time. For the computer it takes less than a second.\n\nFor the first part of the course we will look at three different kinds of computer-assisted proofs:\n\nComputer-assisted proofs for discrete problems\nComputer-assisted proofs for continuous problems\nFormal proofs\n\nFor discrete problems it is relatively easy to imagine that computers could be helpful. An example is problems which reduce to checking a finite number of cases. The most famous problem in this setting is probably the four color theorem, which says that any map can be colored using four colors in such a way that no two adjacent regions have the same color. This was proved in 1976 using a computer-assisted proof. For this they reduced the problem, using pen and paper, to checking 1834 possible counterexamples. These 1834 possible counterexamples were then checked to be four colorable with the help of the computer.\n\nFor continuous problems it is not as obvious how computers could be used. Numerical analysis is a field of mathematics which deals with computing approximate solutions to continuous problems. When numerically solving a problem you introduce discretization errors and rounding errors and these make it so that the final result cannot be fully trusted. A good numerical method will give you a good approximation most of the time, but it is in general not proved to always do so. For mathematical proofs these errors are problematic, it is not enough for the result to be approximately correct. How to deal with this is what most of this course will be about. We look at a subfield of numerical analysis called rigorous numerical analysis, which allows us to control these errors.\n\nFinally, we will talk about formal proofs. Wikipedia gives the following description of formal proofs\n\nIn logic and mathematics, a formal proof or derivation is a finite sequence of sentences (known as well-formed formulas when relating to formal language), each of which is an axiom, an assumption, or follows from the preceding sentences in the sequence, according to the rule of inference. It differs from a natural language argument in that it is rigorous, unambiguous and mechanically verifiable.\n\nFormal proofs are not necessarily computer-assisted, though for anything non-trivial the size of the expressions quickly outgrow anything a human could verify and in practice formal proofs hence require computers for the verification. For writing formal proofs one makes use of special purpose software called proof assistants or interactive theorem provers, example of such softwares are:\n\nIsabelle - Cambridge 1986\nRocq (previously named Coq) - Inria 1989\nAgda - Chalmers 2007 (1999)\nIdris - Edwin Brady 2007\nLean - Microsoft Research 2013\n\nIn particular the last one, Lean, has gained a lot of moment in the last couple of years.\n\nUsing the term computer-assisted for a formal proof is however maybe slightly misleading. In this case the computer is not merely assisting in verifying the proof, it is doing the entire verification completely by itself. We will talk a little bit about formal proofs later in the course, but only with the goal of understanding the difference between a formal proof and a regular computer-assisted proof.","category":"section"},{"location":"week-1-lecture-1/#Part-2:-Introduction-to-rigorous-numerics","page":"Week 1 Lecture 1 - Introduction to computer-assisted proofs","title":"Part 2: Introduction to rigorous numerics","text":"The second part of the course is where we will actually start learning how to build computer-assisted proofs. We will look at the field of rigorous numerical analysis, which is a subfield of numerical analysis. The goal of numerical analysis is to compute approximations, this is also true for rigorous numerical analysis. The difference with rigorous numerical analysis is that in addition to computing an approximation you also compute rigorous upper bounds for the error of your approximation.\n\nAs a simple example, consider the problem of computing e^2. In classical analysis you would do\n\nexp(2)\n\nWhich tells you that e^2 approx 738905609893065 In rigorous numerics you would also compute an approximation, but you would include an upper bound on the error of your approximation.\n\nusing Arblib\nexp(Arb(2, prec = 53))\n\nWhich again tells you that e^2 approx 738905609893065, but it now includes the extra information that the error of this approximation is at most 139 cdot 10^-15, so that e^2 in 738905609893065 pm 139 cdot 10^-15. How is this upper bound for the error computed? That is what we will talk about! It is both fairly technical and surprisingly easy.\n\nTo achieve this we will make use of something called interval arithmetic. In regular numerical analysis one works with floating points, these are inherently approximations since they cannot represent most real numbers exactly. In interval arithmetic one works with pairs of floating points, one representing a lower bound and one representing an upper bound. So instead of e.g. pi approx 3141592653589793 we would have pi in 3141592653589793 31415926535897936. Another format is to use one floating point representing the midpoint and another the radius, so pi in 314159265358979 pm 334 cdot 10^-15. When doing this it is not a problem that most real numbers cannot be represented by floating points, we can always pick the bounds to be floating points. Once we have an interval representation we will still need to do computations with them, exactly how to do this in a rigorous way is probably the most technical part of rigorous numerics.\n\nThe content we will cover over the six weeks are:\n\nMathematical foundations of floating point arithmetic: floating point formats, rounding\nBasics of interval arithmetic: basic arithmetic, elementary functions, special functions\nBasic rigorous numerics: isolating roots, computing integrals, enclosing extrema\nAutomatic differentiation: forward (and backwards) differentiation, Taylor arithmetic\nImproved rigorous numerics: isolating roots, computing integrals, enclosing extrema\n\nA sneak peak at some of the things we will learn how to do, in this case using the Arblib.jl package for interval arithmetic package and some algorithms implemented in ArbExtras.jl.\n\nEnclose roots of functions. For example finding the unique zero of x + e^x on the interval -06 -05\n\nusing Arblib, ArbExtras\nArbExtras.refine_root(x -> x + exp(x), Arb((-3 // 5, -1 // 2)))\n\nEnclose integrals of analytic functions. For example enclosing int_0^5 sin(e^x) dx\n\nusing Arblib\nArblib.integrate(x -> sin(exp(x)), 0, 5)\n\nEnclose the minimum of the function. For example enclosing the minimum of the Bessel function J_4(x) on the interval 1 2.\n\nusing Arblib, ArbExtras, SpecialFunctions\nArbExtras.minimum_enclosure(x -> besselj(Arb(4), x), Arf(1), Arf(2))","category":"section"},{"location":"week-1-lecture-1/#Part-3:-Computer-assisted-proofs-in-practice","page":"Week 1 Lecture 1 - Introduction to computer-assisted proofs","title":"Part 3: Computer-assisted proofs in practice","text":"In the last part of the course we will look at how computer-assisted proofs are actually used in the literature. The goal will be to look at examples of papers making use of computer-assisted proofs. Exactly how we do this and what we will look is however yet to be determined and will depend on your interests. Some areas we could take a closer look at are:\n\nPDEs:. This is the field most of my research takes place in.\nDynamical systems:. This is probably the field with the longest history of computer-assisted proofs and there is a number of interesting things we could look at here.\n\nOne could also discuss things one a more meta level:\n\nWhat exactly does it take to publish a paper with a computer-assisted proof? How does one prepare the code? How does one publish the code? How does one connect the paper and the code?\nWhat type of problems are amendable to a computer-assisted approach? These are things we will touch upon during the course, but one could maybe gain something from discussing it in more detail.\n\nOne could also dive deeper into different algorithms for computer-assisted proofs:\n\nRigorous integration of ODEs\nFinite element methods\nSpectral methods\nPhysics-Informed Neural Networks (PINNs)\n\nAlternatively, one can study the lower level details of interval arithmetic, more related to the field of computer algebra.\n\nWe don't have to decide what to do yet, but as we get further into the course we'll come back to this.","category":"section"},{"location":"week-12/#Week-12-TODO","page":"Week 12 - TODO","title":"Week 12 - TODO","text":"","category":"section"},{"location":"week-6/#Week-6-TODO","page":"Week 6 - TODO","title":"Week 6 - TODO","text":"","category":"section"},{"location":"week-5/#Week-5-TODO","page":"Week 5 - TODO","title":"Week 5 - TODO","text":"","category":"section"},{"location":"week-10/#Week-10-TODO","page":"Week 10 - TODO","title":"Week 10 - TODO","text":"","category":"section"},{"location":"week-11/#Week-11-TODO","page":"Week 11 - TODO","title":"Week 11 - TODO","text":"","category":"section"},{"location":"#Topics-course-in-computer-assisted-proofs-Spring-2026","page":"Overview","title":"Topics course in computer-assisted proofs Spring 2026","text":"This website, together with the associated repository, contains the material for a topics course in computer-assisted proofs and rigorous numerics given at University of Minnesota Spring 2026.\n\nThe general idea of computer-assisted proofs (in analysis), is to build on the massive success of numerical methods in applied mathematics and other sciences and apply them also for mathematical proofs. Classical numerical methods are however not suitable for direct use in proofs, since they introduce errors (rounding and discretization errors). These errors hinder their use in proofs, which require fully rigorous arguments. The area of rigorous numerics tackles these issues by introducing methods to control the errors in a fully rigorous way, that allows for the results to be used in proofs.\n\nAn early, and by now classical, example of a computer-assisted proof is the proof of the existence of the Lorenz attractor in 1999 by Tucker. Over the more than two decades since Tucker's proof, there has been an increase in the adoption of computer assisted proofs in analysis. An example of a recent breakthrough result building on computer-assisted proofs is the proof of blowup for the 3D Euler equation.\n\nThe course is split into 3 parts distributed over 15 weeks. The 3 parts are\n\nIntroduction to computer-assisted proofs (≈ Week 1-4)\nIntroduction to rigorous numerics (≈ Week 5-10)\nComputer-assisted proofs in practice (≈ Week 11-15)\n\nA rough schedule for the first two parts is given below, the precise details for the third part are yet to be determined.\n\nWeek Topic\n1 Introduction to computer-assisted proofs\n2 Discrete problems\n3 Continuous problems\n4 Formal proofs\n5 Floating points and interval arithmetic\n6 Floating points and interval arithmetic\n7 Basic rigorous numerics\n8 Automatic differentiation\n9 Improved rigorous numerics\n10 Improved rigorous numerics\n11 TBD\n12 TBD\n13 TBD\n14 TBD\n15 TBD","category":"section"},{"location":"#Part-1:-Introduction-to-computer-assisted-proofs","page":"Overview","title":"Part 1: Introduction to computer-assisted proofs","text":"The first part of the course will be a general introduction to computer-assisted proofs, from the point of view of rigorous numerics. We will consider both discrete problems, such as the proof of the Four color theorem, and continuous problems, such as the proof of existence of the Lorenz attractor.\n\nComputer-assisted proofs are often mixed up with formal proofs, such as those produced by Lean and Rocq (previously known as Coq), indeed some authors use the term computer-assisted proofs to refer to either. We will take a brief look at formal proofs, with a focus on the differences and similarities between formal proofs and computer-assisted proofs.","category":"section"},{"location":"#Part-2:-Introduction-to-rigorous-numerics","page":"Overview","title":"Part 2: Introduction to rigorous numerics","text":"The second part focuses on the machinery required for constructing computer-assisted proofs in analysis, known as rigorous numerics. This introduction will be partially based on the book Validated Numerics by Warwick Tucker. At the heart of rigorous numerics lies interval arithmetic, indeed the field of rigorous numerics is sometimes just referred to as interval arithmetic.\n\nThe practical parts will primarily be done in Julia, using the packages Arblib.jl and IntervalArithmetic.jl as the base for the interval arithmetic.\n\nHere is an example of how interval arithmetic looks like in practice, here using IntervalArithmetic.jl.\n\nusing IntervalArithmetic\na = interval(1, 2) # The interval [1, 2]\na^2 # Interval gotten from squaring all numbers in [1, 2]\nsin(a) # Interval gotten from applying sin to all numbers in [1, 2]\n\nThe content we will cover includes:\n\nMathematical foundations of floating point arithmetic: floating point formats, rounding\nBasics of interval arithmetic: basic arithmetic, elementary functions, special functions\nBasic rigorous numerics: isolating roots, computing integrals, enclosing extrema\nAutomatic differentiation: forward (and backwards) differentiation, Taylor arithmetic\nImproved rigorous numerics: isolating roots, computing integrals, enclosing extrema","category":"section"},{"location":"#Part-3:-Computer-assisted-proofs-in-practice","page":"Overview","title":"Part 3: Computer-assisted proofs in practice","text":"In the third and final part of the course we will look at what it takes to go from what we have learned about interval arithmetic and rigorous numerics to actually creating a computer-assisted proof. The list of topics covered would depend on the interests of the participants in the course. Possible topics would include the use of computer-assisted proofs in:\n\nSpectral geometry\nDynamical systems\nFluid mechanics\nAnalytic combinatorics\n\nOne could also dive deeper into different algorithms for computer-assisted proofs:\n\nRigorous integration of ODEs\nFinite element methods\nSpectral methods\nPhysics-Informed Neural Networks (PINNs)\n\nAlternatively, one can study the lower level details of interval arithmetic, more related to the field of computer algebra.","category":"section"},{"location":"week-7/#Week-7-TODO","page":"Week 7 - TODO","title":"Week 7 - TODO","text":"","category":"section"}]
}
