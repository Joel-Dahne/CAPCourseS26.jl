<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Week 2 Lecture 2: Integer arithmetic · CAPCourseS26.jl</title><meta name="title" content="Week 2 Lecture 2: Integer arithmetic · CAPCourseS26.jl"/><meta property="og:title" content="Week 2 Lecture 2: Integer arithmetic · CAPCourseS26.jl"/><meta property="twitter:title" content="Week 2 Lecture 2: Integer arithmetic · CAPCourseS26.jl"/><meta name="description" content="Documentation for CAPCourseS26.jl."/><meta property="og:description" content="Documentation for CAPCourseS26.jl."/><meta property="twitter:description" content="Documentation for CAPCourseS26.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CAPCourseS26.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><span class="tocitem">Weeks</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox" checked/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Part 1: Introduction to computer-assisted proofs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../week-1-lecture-1/">Week 1 Lecture 1 - Introduction to computer-assisted proofs</a></li><li><a class="tocitem" href="../week-1-lab/">Week 1 Lab: Setup</a></li><li><a class="tocitem" href="../week-2-lecture-1/">Week 2 Lecture 1: Discrete problems</a></li><li class="is-active"><a class="tocitem" href>Week 2 Lecture 2: Integer arithmetic</a><ul class="internal"><li><a class="tocitem" href="#Integer-types"><span>Integer types</span></a></li><li><a class="tocitem" href="#Arithmetic"><span>Arithmetic</span></a></li><li><a class="tocitem" href="#Overflow"><span>Overflow</span></a></li><li><a class="tocitem" href="#Performance"><span>Performance</span></a></li><li><a class="tocitem" href="#Flint"><span>Flint</span></a></li></ul></li><li><a class="tocitem" href="../week-2-lab/">Week 2 Lab: Julia basics</a></li><li><a class="tocitem" href="../week-3-lecture-1/">Week 3 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-3-lecture-2/">Week 3 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-3-lab/">Week 3 Lab: TODO</a></li><li><a class="tocitem" href="../week-4-lecture-1/">Week 4 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-4-lecture-2/">Week 4 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-4-lab/">Week 4 Lab: TODO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Part 2: Introduction to rigorous numerics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../week-5-lecture-1/">Week 5 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-5-lecture-2/">Week 5 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-5-lab/">Week 5 Lab: TODO</a></li><li><a class="tocitem" href="../week-6-lecture-1/">Week 6 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-6-lecture-2/">Week 6 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-6-lab/">Week 6 Lab: TODO</a></li><li><a class="tocitem" href="../week-7-lecture-1/">Week 7 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-7-lecture-2/">Week 7 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-7-lab/">Week 7 Lab: TODO</a></li><li><a class="tocitem" href="../week-8-lecture-1/">Week 8 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-8-lecture-2/">Week 8 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-8-lab/">Week 8 Lab: TODO</a></li><li><a class="tocitem" href="../week-9-lecture-1/">Week 9 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-9-lecture-2/">Week 9 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-9-lab/">Week 9 Lab: TODO</a></li><li><a class="tocitem" href="../week-10-lecture-1/">Week 10 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-10-lecture-2/">Week 10 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-10-lab/">Week 10 Lab: TODO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Part 3: Computer-assisted proofs in practice</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../week-11-lecture-1/">Week 11 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-11-lecture-2/">Week 11 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-11-lab/">Week 11 Lab: TODO</a></li><li><a class="tocitem" href="../week-12-lecture-1/">Week 12 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-12-lecture-2/">Week 12 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-12-lab/">Week 12 Lab: TODO</a></li><li><a class="tocitem" href="../week-13-lecture-1/">Week 13 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-13-lecture-2/">Week 13 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-13-lab/">Week 13 Lab: TODO</a></li><li><a class="tocitem" href="../week-14-lecture-1/">Week 14 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-14-lecture-2/">Week 14 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-14-lab/">Week 14 Lab: TODO</a></li><li><a class="tocitem" href="../week-15-lecture-1/">Week 15 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-15-lecture-2/">Week 15 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-15-lab/">Week 15 Lab: TODO</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Weeks</a></li><li><a class="is-disabled">Part 1: Introduction to computer-assisted proofs</a></li><li class="is-active"><a href>Week 2 Lecture 2: Integer arithmetic</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Week 2 Lecture 2: Integer arithmetic</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Joel-Dahne/CAPCourseS26.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Joel-Dahne/CAPCourseS26.jl/blob/main/docs/src/week-2-lecture-2.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Week-2-Lecture-2:-Integer-arithmetic"><a class="docs-heading-anchor" href="#Week-2-Lecture-2:-Integer-arithmetic">Week 2 Lecture 2: Integer arithmetic</a><a id="Week-2-Lecture-2:-Integer-arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#Week-2-Lecture-2:-Integer-arithmetic" title="Permalink"></a></h1><p>In this lecture we will focus not on any specific computer-assisted proof, but rather on one of the fundamental building blocks for computer-assisted proofs, integer arithmetic. The lecture will also serve as a bit of introduction to parts of the Julia programming language. It could be useful to open a Julia REPL on the side while reading this and experiment with some of the code shown.</p><p>To make use of computers for proofs we need to be able to trust the computations they do. For numerical analysis, which relies on floating point numbers and approximations, trusting the computer requires a bit of work. This is what we will get to later in the course when we talk about rigorous numerics. For integer arithmetic most people would however probably agree that the computer can be trusted to do it right.</p><p>When we in a couple of weeks get to rigorous numerics and more closely study floating points we will see that everything in the end reduces to integer arithmetic. So it makes sense to look a bit closer at this and understand how it works.</p><h2 id="Integer-types"><a class="docs-heading-anchor" href="#Integer-types">Integer types</a><a id="Integer-types-1"></a><a class="docs-heading-anchor-permalink" href="#Integer-types" title="Permalink"></a></h2><p>There are many different ways to represent integers on the computer, the most important aspects in the choice of representation being the size of the integers and if one needs negative integers or not. For our purposes we will mostly work with integer types that do allow negative numbers, called signed integers. We will briefly talk about unsigned integers at the end of this section.</p><p>For the size one could either have a fixed predetermined size that can represent integers up to some fixed bound, or a variable size that can represent arbitrarily large integers (until your computer runs out of memory). Julia has the types <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, <code>Int64</code> and <code>Int128</code> for representing fixed-width integers, where the number indicates the number of bits used to store the integer. The minimum and maximum integer that is representable using these types can be found using <code>typemin</code> and <code>typemax</code> respectively.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typemin(Int8)</code><code class="nohighlight hljs ansi" style="display:block;">-128</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typemax(Int8)</code><code class="nohighlight hljs ansi" style="display:block;">127</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typemin(Int16), typemax(Int16)</code><code class="nohighlight hljs ansi" style="display:block;">(-32768, 32767)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typemin(Int32), typemax(Int32)</code><code class="nohighlight hljs ansi" style="display:block;">(-2147483648, 2147483647)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typemin(Int64), typemax(Int64)</code><code class="nohighlight hljs ansi" style="display:block;">(-9223372036854775808, 9223372036854775807)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typemin(Int128), typemax(Int128)</code><code class="nohighlight hljs ansi" style="display:block;">(-170141183460469231731687303715884105728, 170141183460469231731687303715884105727)</code></pre><p>The default integer type on most modern computers is <code>Int64</code>, the <code>Int</code> type in Julia is a shorthand for the default type. If you directly write an integer it will be of type <code>Int</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Int</code><code class="nohighlight hljs ansi" style="display:block;">Int64</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(5)</code><code class="nohighlight hljs ansi" style="display:block;">Int64</code></pre><p>For representing arbitrary-sized integers Julia has the type <code>BigInt</code>. In this case there is no <code>typemin</code> or <code>typemax</code> defined</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typemin(BigInt)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching typemin(::Type{BigInt})
The function `typemin` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  typemin(<span class="sgr91">::Type{REPL.TerminalMenus.Key}</span>)
<span class="sgr90">   @</span> <span class="sgr35">REPL</span> <span class="sgr90"><span class="sgr4">Enums.jl:216</span></span>
  typemin(<span class="sgr91">::Type{LibGit2.Consts.GIT_BRANCH}</span>)
<span class="sgr90">   @</span> <span class="sgr36">LibGit2</span> <span class="sgr90"><span class="sgr4">Enums.jl:216</span></span>
  typemin(<span class="sgr91">::Type{Arblib.arb_rnd}</span>)
<span class="sgr90">   @</span> <span class="sgr32">Arblib</span> <span class="sgr90"><span class="sgr4">Enums.jl:216</span></span>
  ...</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typemax(BigInt)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching typemax(::Type{BigInt})
The function `typemax` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  typemax(<span class="sgr91">::Type{REPL.TerminalMenus.Key}</span>)
<span class="sgr90">   @</span> <span class="sgr35">REPL</span> <span class="sgr90"><span class="sgr4">Enums.jl:217</span></span>
  typemax(<span class="sgr91">::Type{LibGit2.Consts.GIT_BRANCH}</span>)
<span class="sgr90">   @</span> <span class="sgr36">LibGit2</span> <span class="sgr90"><span class="sgr4">Enums.jl:217</span></span>
  typemax(<span class="sgr91">::Type{Arblib.arb_rnd}</span>)
<span class="sgr90">   @</span> <span class="sgr32">Arblib</span> <span class="sgr90"><span class="sgr4">Enums.jl:217</span></span>
  ...</code></pre><p>You can convert an integer from one type to any other type. If the integer is too large to be represented in the new type an error is thrown.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Int16(5)</code><code class="nohighlight hljs ansi" style="display:block;">5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(Int16(5))</code><code class="nohighlight hljs ansi" style="display:block;">Int16</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; BigInt(1000)</code><code class="nohighlight hljs ansi" style="display:block;">1000</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; big(1000) # Shorthand for BigInt(1000) in this case</code><code class="nohighlight hljs ansi" style="display:block;">1000</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Int8(300) # 300 doesn&#39;t fit in one Int8</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: InexactError: trunc(Int8, 300)</code></pre><p>You can see exactly what bits are used to represent an integer using <code>bitstring</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bitstring(7)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;0000000000000000000000000000000000000000000000000000000000000111&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bitstring(2^14)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;0000000000000000000000000000000000000000000000000100000000000000&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bitstring(Int32(2^14))</code><code class="nohighlight hljs ansi" style="display:block;">&quot;00000000000000000100000000000000&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bitstring(Int16(2^14))</code><code class="nohighlight hljs ansi" style="display:block;">&quot;0100000000000000&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bitstring(Int8(2^14)) # Too small to fit 2^14</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: InexactError: trunc(Int8, 16384)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bitstring(BigInt(2^14)) # bitstring doesn&#39;t work for BigInt</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: ArgumentError: BigInt not a primitive type</code></pre><p>For fixed-width integers negative values are represented using <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two&#39;s complement</a>, whereas arbitrary-sized integers usually have a separate bit that keeps track of the sign. The details here are not so important for our purposes though.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bitstring(-7)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;1111111111111111111111111111111111111111111111111111111111111001&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bitstring(Int32(-7))</code><code class="nohighlight hljs ansi" style="display:block;">&quot;11111111111111111111111111111001&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bitstring(Int16(-7))</code><code class="nohighlight hljs ansi" style="display:block;">&quot;1111111111111001&quot;</code></pre><h2 id="Arithmetic"><a class="docs-heading-anchor" href="#Arithmetic">Arithmetic</a><a id="Arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic" title="Permalink"></a></h2><p>How arithmetic of integers is done depends on their type.</p><p>For <code>Int32</code> and <code>Int64</code> basic arithmetic is typically implemented directly in hardware on the CPU. So you don&#39;t write a program for multiplying two such integers, you use the implementation on the CPU. The correctness of this procedure is therefore dependent on the correctness of the CPU, which for even remotely modern CPU you can assume.</p><p>For smaller integer types, e.g. <code>Int8</code> and <code>Int16</code>, arithmetic is often times handled by converting them to <code>Int32</code> or <code>Int64</code>, doing the operation and then converting back. One would in general not expect these operations to be any faster than those for <code>Int32</code> and <code>Int64</code>. Some hardware might have specialized instructions for these, in which case it could be much faster though.</p><p>For <code>BigInt</code> the arithmetic is implemented in software. Internally they are built up of a list of <code>Int64</code> that is treated as one large integer. Operations are then implemented by combining several operations for <code>Int64</code> values. For addition this is relatively simple and something you could implement yourself with a bit of time. For multiplication this becomes extremely complicated and requires both highly sophisticated mathematical methods and carefully crafted implementations to achieve top performance. The <code>BigInt</code> type in Julia is internally based on the <a href="https://gmplib.org/">GMP library</a> which contains highly specialized code for operating on such integers.</p><h2 id="Overflow"><a class="docs-heading-anchor" href="#Overflow">Overflow</a><a id="Overflow-1"></a><a class="docs-heading-anchor-permalink" href="#Overflow" title="Permalink"></a></h2><p>For fixed-width integer types we have to somehow handle when the value is too large to be represented by the type. For conversion to integer types we have already seen that it throws an error if the value doesn&#39;t fit.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Int8(300) # 300 doesn&#39;t fit in one Int8</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: InexactError: trunc(Int8, 300)</code></pre><p>When doing arithmetic on integers it does however not throw an error, instead the result wraps around.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typemin(Int8), typemax(Int8) # Recall these values</code><code class="nohighlight hljs ansi" style="display:block;">(-128, 127)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typemax(Int8) + Int8(1)</code><code class="nohighlight hljs ansi" style="display:block;">-128</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typemin(Int64), typemax(Int64) # Recall these values</code><code class="nohighlight hljs ansi" style="display:block;">(-9223372036854775808, 9223372036854775807)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typemax(Int64) + 1</code><code class="nohighlight hljs ansi" style="display:block;">-9223372036854775808</code></pre><p>When this happens it is called <strong>integer overflow</strong>. The behavior here does however depend on the programming language used. For example in C, integer overflow is considered undefined behavior and a program which exhibits overflow is not guaranteed to work as expected. In Julia, and many other languages, the behavior is well defined. For <code>Int64</code> the behavior is isomorphic to <span>$\mathbb{Z}_{2^{64}}$</span>, with the representatives centered around zero.</p><p>This overflow behavior means that you have to be careful when working with integers for mathematical purposes. For fixed-width integer arithmetic to faithfully represent integer arithmetic you have to ensure (prove) that your operations never overflow. In many cases overflow is not a problem. For example, computing Pythagorean triples up to 1784 using <code>Int64</code> will clearly not give you any issues with overflow. But if you want to verify Goldbach&#39;s weak conjecture up to <span>$10^{30} \approx 2^{100}$</span> you won&#39;t be able to do it using <code>Int64</code>. If you want to be on the safe side you can always use <code>BigInt</code>, which never overflows (it will just crash if you run out of memory). In some programming languages, e.g. Python, the default is that integers are represented using an arbitrary-sized representation.</p><p>With these issues coming from overflow, why would one not simply use <code>BigInt</code> all the time? The answer is performance, it is significantly slower.</p><h2 id="Performance"><a class="docs-heading-anchor" href="#Performance">Performance</a><a id="Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Performance" title="Permalink"></a></h2><p>Let us take a brief look how performance for various integer types compare. Let us consider the problem of computing</p><p class="math-container">\[\sum_{n = 1}^N n^b\]</p><p>for some integers <span>$N$</span> and <span>$b$</span>. In Julia this could be implemented as</p><pre><code class="language-julia hljs">function f(N::Integer, b::Integer)
    # Writing just &quot;0&quot; would give us an Int64, zero(N) gives us a zero of the same type as N
    S = zero(N)
    # Same with one(N) here
    for n in one(N):N
        S += n^b
    end
    return S
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">f (generic function with 1 method)</code></pre><p>Let us take <span>$b = 2$</span>, we can evaluate the function using a variety of types</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(1000, 2)</code><code class="nohighlight hljs ansi" style="display:block;">333833500</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(Int32(1000), Int32(2))</code><code class="nohighlight hljs ansi" style="display:block;">333833500</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(Int16(1000), Int16(2)) # This overflows!</code><code class="nohighlight hljs ansi" style="display:block;">-6884</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(BigInt(1000), BigInt(2))</code><code class="nohighlight hljs ansi" style="display:block;">333833500</code></pre><p>To benchmark these different versions we use the Julia package <a href="https://github.com/JuliaCI/BenchmarkTools.jl">BenchmarkTools.jl</a>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using BenchmarkTools</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @benchmark f($1000, $2) samples = 10000 evals = 10</code><code class="nohighlight hljs ansi" style="display:block;">BenchmarkTools.Trial: 10000 samples with 10 evaluations per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">1.858 μs</span></span> … <span class="sgr35">  6.612 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">1.860 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">1.877 μs</span></span> ± <span class="sgr32">131.417 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

  <span class="sgr34">█</span><span class="sgr32"> </span>                                                          ▁
  <span class="sgr34">█</span><span class="sgr32">▃</span>▄▃▁▄█▃▁▁▁▁▁▁▄▄▅▄▃▁▃▃▃▁▁▁▁▁▁▁▁▁▁▁▁▃▁▁▁▁▁▁▁▃▁▁▁▃▃▁▁▁▁▁▄▄▆█▇ █
  1.86 μs<span class="sgr90">      Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>       2.6 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">0 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">0</span>.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @benchmark f(Int32($1000), Int32($2)) samples = 10000 evals = 10</code><code class="nohighlight hljs ansi" style="display:block;">BenchmarkTools.Trial: 10000 samples with 10 evaluations per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">2.166 μs</span></span> … <span class="sgr35">  4.974 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">2.168 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">2.189 μs</span></span> ± <span class="sgr32">133.489 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

  <span class="sgr34">█</span> <span class="sgr32"> </span>                                                         ▁
  <span class="sgr34">█</span>▃<span class="sgr32">▁</span>▄▄▃█▃▁▁▁▁▁▁▅▆▅▃▁▄▁▁▁▁▁▁▃▁▃▁▁▁▁▁▃▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄▆███ █
  2.17 μs<span class="sgr90">      Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>      2.91 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">0 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">0</span>.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @benchmark f(Int16($1000), Int16($2)) samples = 10000 evals = 10</code><code class="nohighlight hljs ansi" style="display:block;">BenchmarkTools.Trial: 10000 samples with 10 evaluations per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">1.859 μs</span></span> … <span class="sgr35">  4.732 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">1.862 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">1.880 μs</span></span> ± <span class="sgr32">122.247 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

  <span class="sgr34">█</span> <span class="sgr32"> </span>                                                         ▁
  <span class="sgr34">█</span>▃<span class="sgr32">▃</span>▁▄▁▇▁▁▁▃▁▁▁▁▄▅▅▃▁▃▃▁▄▁▁▃▁▁▃▁▁▁▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄▄▄▆██ █
  1.86 μs<span class="sgr90">      Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>       2.6 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">0 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">0</span>.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @benchmark f(BigInt($1000), BigInt($2)) samples = 5000 evals = 1</code><code class="nohighlight hljs ansi" style="display:block;">BenchmarkTools.Trial: 5000 samples with 1 evaluation per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">218.798 μs</span></span> … <span class="sgr35">167.874 ms</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span> 0.00% … 65.83%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">238.239 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span> 0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">502.742 μs</span></span> ± <span class="sgr32">  5.290 ms</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>29.62% ±  2.86%

  ▃▆█▆▆<span class="sgr34">▅</span>▃▂▃▄▆▃▄▃▂       ▂▁       ▂▂▃▂▂▁                         ▁
  █████<span class="sgr34">█</span>███████████▇▇▇██████▇▅▅▄▇██████▇▆▆▄▅▄▅▇▆▇▆▆▃▆▅▄▄▅▅▅▅▅▅▆ █
  219 μs<span class="sgr90">        Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>        445 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">343.68 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">12997</span>.</code></pre><div class="admonition is-info" id="Note-1bac83204ee98105"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-1bac83204ee98105" title="Permalink"></a></header><div class="admonition-body"><p>The <code>$</code>-signs in the code below are part of the BenchmarkTools interface and are there to avoid the compiler being too clever and optimizing away what we want to measure.</p><p>The extra arguments <code>samples</code> and <code>evals</code> are not required. If you run the code yourself you can remove them. They are here to reduce the time to build this documentation.</p></div></div><p>The most important number in the above benchmarks is the minimum time. The mean time is also important in practice, but is affected by variables we are not controlling for here.</p><h2 id="Flint"><a class="docs-heading-anchor" href="#Flint">Flint</a><a id="Flint-1"></a><a class="docs-heading-anchor-permalink" href="#Flint" title="Permalink"></a></h2><p>While we are discussing integer arithmetic it is also natural to introduce the library that will be the foundation for a lot of the rigorous numerics we will get to later in the course. The <a href="https://flintlib.org/">FLINT</a> library is a C library with high performance implementations of many computer algebra algorithms. FLINT stands for &quot;Fast Library for Number Theory&quot;, but much of the functionality is useful outside of number theory as well.</p><p>We will not make use of Flint directly, instead we will use it through the Julia package <a href="https://github.com/kalmarek/Arblib.jl">Arblib.jl</a> that wraps (most of) the parts of the library related to rigorous numerics. In fact, there is not really any need for you to know about the Flint library at all for what we will do in the course.</p><div class="admonition is-info" id="Note-c74550cb2efae844"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c74550cb2efae844" title="Permalink"></a></header><div class="admonition-body"><p>The reason for the library being called Flint but the Julia package being called Arblib is that the parts of Flint that Arblib wraps were previously a separate library called Arb (Arbitrary precision Real Balls). The Arb library, and several others, were merged into Flint in 2023.</p></div></div><p>The Flint library implements many standard computer algebra algorithms over a large variety of different rings. Some of the rings it implements are</p><ul><li>Integers</li><li>Rational numbers</li><li>Integers mod <span>$n$</span></li><li>Real and complex numbers (this is the rigorous numerics part)</li><li>Exact real and complex numbers (this is more symbolical in nature)</li><li>Finite fields</li><li><span>$p$</span>-adic numbers</li></ul><p>For our purposes we will primarily deal with the real and complex numbers, though these internally depend on the integers and rational numbers. For these rings it implements a number of different algorithms related to e.g. polynomials, matrices and special functions. Unless specified otherwise, the Flint library can be assumed to always return mathematically rigorous results.</p><p>In many areas the Flint implementations are the state of the art and sometimes greatly outperform other implementations. It&#39;s used by many programs for computationally heavy computations, for example <a href="https://www.sagemath.org/">Sage</a> uses it internally for many things.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../week-2-lecture-1/">« Week 2 Lecture 1: Discrete problems</a><a class="docs-footer-nextpage" href="../week-2-lab/">Week 2 Lab: Julia basics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 30 January 2026 16:00">Friday 30 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
