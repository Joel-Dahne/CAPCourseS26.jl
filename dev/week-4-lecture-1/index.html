<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Week 4 Lecture 1: Formal proofs · CAPCourseS26.jl</title><meta name="title" content="Week 4 Lecture 1: Formal proofs · CAPCourseS26.jl"/><meta property="og:title" content="Week 4 Lecture 1: Formal proofs · CAPCourseS26.jl"/><meta property="twitter:title" content="Week 4 Lecture 1: Formal proofs · CAPCourseS26.jl"/><meta name="description" content="Documentation for CAPCourseS26.jl."/><meta property="og:description" content="Documentation for CAPCourseS26.jl."/><meta property="twitter:description" content="Documentation for CAPCourseS26.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CAPCourseS26.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><span class="tocitem">Weeks</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox" checked/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Part 1: Introduction to computer-assisted proofs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../week-1-lecture-1/">Week 1 Lecture 1 - Introduction to computer-assisted proofs</a></li><li><a class="tocitem" href="../week-1-lab/">Week 1 Lab: Setup</a></li><li><a class="tocitem" href="../week-2-lecture-1/">Week 2 Lecture 1: Discrete problems</a></li><li><a class="tocitem" href="../week-2-lecture-2/">Week 2 Lecture 2: Integer arithmetic</a></li><li><a class="tocitem" href="../week-2-lab/">Week 2 Lab: Julia basics</a></li><li><a class="tocitem" href="../week-3-lecture-1/">Week 3 Lecture 1: Computer-assisted proofs for continuous problems</a></li><li><a class="tocitem" href="../week-3-lecture-2/">Week 3 Lecture 2: Computer-assisted proofs for continuous problems</a></li><li><a class="tocitem" href="../week-3-lab/">Week 3 Lab: A simple computer-assisted proof (and VS Code)</a></li><li class="is-active"><a class="tocitem" href>Week 4 Lecture 1: Formal proofs</a><ul class="internal"><li><a class="tocitem" href="#Some-recent-developments-and-resources"><span>Some recent developments and resources</span></a></li><li><a class="tocitem" href="#A-glimpse-of-Lean"><span>A glimpse of Lean</span></a></li><li><a class="tocitem" href="#What-is-a-formal-proof?"><span>What is a formal proof?</span></a></li></ul></li><li><a class="tocitem" href="../week-4-lecture-2/">Week 4 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-4-lab/">Week 4 Lab: TODO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Part 2: Introduction to rigorous numerics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../week-5-lecture-1/">Week 5 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-5-lecture-2/">Week 5 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-5-lab/">Week 5 Lab: TODO</a></li><li><a class="tocitem" href="../week-6-lecture-1/">Week 6 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-6-lecture-2/">Week 6 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-6-lab/">Week 6 Lab: TODO</a></li><li><a class="tocitem" href="../week-7-lecture-1/">Week 7 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-7-lecture-2/">Week 7 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-7-lab/">Week 7 Lab: TODO</a></li><li><a class="tocitem" href="../week-8-lecture-1/">Week 8 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-8-lecture-2/">Week 8 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-8-lab/">Week 8 Lab: TODO</a></li><li><a class="tocitem" href="../week-9-lecture-1/">Week 9 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-9-lecture-2/">Week 9 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-9-lab/">Week 9 Lab: TODO</a></li><li><a class="tocitem" href="../week-10-lecture-1/">Week 10 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-10-lecture-2/">Week 10 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-10-lab/">Week 10 Lab: TODO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Part 3: Computer-assisted proofs in practice</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../week-11-lecture-1/">Week 11 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-11-lecture-2/">Week 11 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-11-lab/">Week 11 Lab: TODO</a></li><li><a class="tocitem" href="../week-12-lecture-1/">Week 12 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-12-lecture-2/">Week 12 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-12-lab/">Week 12 Lab: TODO</a></li><li><a class="tocitem" href="../week-13-lecture-1/">Week 13 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-13-lecture-2/">Week 13 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-13-lab/">Week 13 Lab: TODO</a></li><li><a class="tocitem" href="../week-14-lecture-1/">Week 14 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-14-lecture-2/">Week 14 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-14-lab/">Week 14 Lab: TODO</a></li><li><a class="tocitem" href="../week-15-lecture-1/">Week 15 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-15-lecture-2/">Week 15 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-15-lab/">Week 15 Lab: TODO</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Weeks</a></li><li><a class="is-disabled">Part 1: Introduction to computer-assisted proofs</a></li><li class="is-active"><a href>Week 4 Lecture 1: Formal proofs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Week 4 Lecture 1: Formal proofs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Joel-Dahne/CAPCourseS26.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Joel-Dahne/CAPCourseS26.jl/blob/main/docs/src/week-4-lecture-1.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Week-4-Lecture-1:-Formal-proofs"><a class="docs-heading-anchor" href="#Week-4-Lecture-1:-Formal-proofs">Week 4 Lecture 1: Formal proofs</a><a id="Week-4-Lecture-1:-Formal-proofs-1"></a><a class="docs-heading-anchor-permalink" href="#Week-4-Lecture-1:-Formal-proofs" title="Permalink"></a></h1><p>This week we will take a slight detour in our study of computer-assisted proofs and talk about formal proofs. Computer-assisted proofs and formal proofs are related, in the sense that they both make use of the computer for verification. However, they are very different in what they aim to do and practical use of them looks very different.</p><p>Computer-assisted proofs aim to tackle the problem of humans being bad (or at least slow) at performing large scale computations. Using pen and paper one reduces the problem to a computational problem, which is then handled by the computer.</p><p>Formal proofs aim to tackle the problem of humans making errors in their logic. A formal proof covers the whole proof, from the statement of the theorem to every step in the proof.</p><p>The goal of this week is not to make you experts in formal proofs, but rather to give you enough of an idea of what a formal proof is to be able to compare it to computer-assisted proofs. We will look at the mathematical foundations for formal proofs, historical examples of formal proofs as well as recent developments in the field.</p><div class="admonition is-info" id="Info-43fc89ada08404b9"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-43fc89ada08404b9" title="Permalink"></a></header><div class="admonition-body"><p>As mentioned in the first lecture, different mathematicians mean different things when they say &quot;computer-assisted proof&quot;. Some mathematicians would include formal proofs in the general field of computer-assisted proofs.</p></div></div><h2 id="Some-recent-developments-and-resources"><a class="docs-heading-anchor" href="#Some-recent-developments-and-resources">Some recent developments and resources</a><a id="Some-recent-developments-and-resources-1"></a><a class="docs-heading-anchor-permalink" href="#Some-recent-developments-and-resources" title="Permalink"></a></h2><p>The interest in formal proofs has seen a rise in recent years. This is likely driven by a combination of the tools for formal proofs maturing, making them more accessible, and the rise of generative AI giving hope for semi-automatic translation from pen and paper proofs to formal proofs.</p><p>A recent example of the use of formal proofs which is also somewhat relevant to our study of computer-assisted proofs is the <a href="https://www.ipam.ucla.edu/news-research/special-projects/integrated-explicit-analytic-number-theory-network/">Integrated Explicit Analytic Number Theory network</a>. They aim to formally verify effective inequalities with explicit constants that arise in analytic number theory. From their description you can read</p><blockquote><p>With unspecified constants, such bounds are well understood and can be found in many textbooks (and have even been formalized in several proof assistant languages, including Lean). However, with explicit constants, the results are only contained in a few papers which are full of routine but tedious computations. Furthermore, while bounds with unspecified constants are quite robust with respect to minor typos in the arguments, explicit constant bounds can be extremely fragile, with a single arithmetic error causing all subsequent bounds to be untrustworthy.</p></blockquote><p>In a <a href="https://mathstodon.xyz/@tao/116037574125913104">Mathstodon post</a> Terence Tao mentions that some of these computations make use of interval arithmetic for some of the internal calculations, for example for computing bounds for <span>$\log 2$</span>. He also mentions in a project <a href="https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/wiki/Terence-Tao&#39;s-personal-log#day-13-jan-27-2026">log book</a> that some of the original papers contain minor errors in the constants coming from the use of non-rigorous floating point arithmetic.</p><p>Some other resources:</p><ul><li>For PDEs there was recently a [Lean for</li></ul><p>PDE](https://www.slmath.org/workshops/1180) workshop organized at SLMath.</p><ul><li>Terence Tao has some <a href="https://www.youtube.com/@TerenceTao27">Youtube videos</a> showing what formalizing a proof in Lean could look like in practice.</li></ul><h2 id="A-glimpse-of-Lean"><a class="docs-heading-anchor" href="#A-glimpse-of-Lean">A glimpse of Lean</a><a id="A-glimpse-of-Lean-1"></a><a class="docs-heading-anchor-permalink" href="#A-glimpse-of-Lean" title="Permalink"></a></h2><p>Most (but not all) of the recent developments in formal proofs make use of <a href="https://lean-lang.org/">Lean</a>. To get a feeling for what we are dealing with, let us take a brief look at what statements written in Lean could look like.</p><p>For these examples we will make use of the <a href="https://github.com/teorth/analysis#">Lean formalization of Analysis I</a>, a formalization of the <a href="https://terrytao.wordpress.com/books/analysis-i/">Analysis I</a> textbook by Terence Tao. The emphasis in the book is on rigour and on foundations and starts with set theory and construction of the natural numbers.</p><p>We will look at some examples of statements from this book. To make use of Lean&#39;s functionality for interactively working with statements we will use VS Code to demo this. We do not include the details of the demo here, but the chapters of the book we will look at are</p><ul><li>Section 2.1: The Peano axioms (<a href="https://github.com/teorth/analysis/blob/main/analysis/Analysis/Section_2_1.lean">Lean source</a>)</li><li>Section 10.2: Local maxima, local minima, and derivatives (<a href="https://github.com/teorth/analysis/blob/main/analysis/Analysis/Section_10_2.lean">Lean source</a>)</li><li>Section 11.4: Basic properties of the Riemann integral (<a href="https://github.com/teorth/analysis/blob/main/analysis/Analysis/Section_11_4.lean">Lean source</a>): Primarily Theorem 11.4.5.</li></ul><h2 id="What-is-a-formal-proof?"><a class="docs-heading-anchor" href="#What-is-a-formal-proof?">What is a formal proof?</a><a id="What-is-a-formal-proof?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-a-formal-proof?" title="Permalink"></a></h2><p>We have now seen some examples of what formal proofs could look like in practice. But how are these proofs actually checked? What foundations are these built on?</p><p>To understand this we will take a brief look at three core concepts: the correspondence between programs and proofs, the language used to express them, and the architecture that allows us to trust the software.</p><h3 id="The-Curry-Howard-Correspondence"><a class="docs-heading-anchor" href="#The-Curry-Howard-Correspondence">The Curry-Howard Correspondence</a><a id="The-Curry-Howard-Correspondence-1"></a><a class="docs-heading-anchor-permalink" href="#The-Curry-Howard-Correspondence" title="Permalink"></a></h3><p>The most fundamental concept to grasp is that in formal verification, there is a deep structural link between logic and programming. This is known as the <strong>Curry-Howard correspondence</strong> (or &quot;Propositions as Types&quot;).</p><p>In a standard programming language, you have <strong>types</strong> (like <code>int</code>, <code>string</code>, <code>List</code>) and <strong>values</strong> or <strong>programs</strong> that inhabit those types (like <code>5</code>, <code>&quot;hello&quot;</code>, <code>[1, 2]</code>).</p><p>In the world of formal proofs:</p><ul><li>A mathematical proposition (statement) is a Type.</li><li>A proof of that proposition is a Program (value) of that Type.</li></ul><p>Therefore, &quot;checking a proof&quot; is reduced to &quot;type-checking a program.&quot; If you write a function that claims to return an integer but actually returns a string, the compiler throws a type error. Similarly, if you write a proof that claims to prove Theorem X but contains a logical gap, the formal system throws a type error.</p><p>You can see this correspondence directly in Lean code (at least if you have some experience with functional programming languages). Take for example</p><pre><code class="language-lean-4 hljs">/--
  Axiom 2.4 (Different natural numbers have different successors).
  Compare with Mathlib&#39;s `Nat.succ_inj`.
-/
theorem Nat.succ_cancel {n m:Nat} (hnm: n++ = m++) : n = m := by
  injection hnm</code></pre><p>Here <code>Nat.succ_cancel</code> is a function that takes as input <code>n</code> and <code>m</code>, both of type <code>Nat</code> as well as <code>hnm</code> which is of type <code>n++ = m++</code> and returns a value of type <code>n = m</code>. In most programming languages treating <code>n = m</code> as a type doesn&#39;t make much sense, but in Lean it does. What comes after the <code>:=</code> part is what in a normal programming language would correspond to the implementation of the function.</p><p>A concrete example of this correspondence is implications. The mathematical statement that <span>$P \implies Q$</span> corresponds to a function that takes as input a value of type <code>P</code> and returns an output of type <code>Q</code>. The proof of the statement corresponds to the implementation of the function.</p><h3 id="Dependent-Type-Theory"><a class="docs-heading-anchor" href="#Dependent-Type-Theory">Dependent Type Theory</a><a id="Dependent-Type-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Dependent-Type-Theory" title="Permalink"></a></h3><p>To make the Curry-Howard correspondence work for complex mathematics one needs a type system that is <strong>much</strong> richer than what is found in standard languages like C or Julia or even Haskell. There are different approaches for this and different proof assistants use different systems. The system Lean is based on is called <strong>Dependent Type Theory</strong>.</p><p>Most standard programming languages have types like <code>Bool</code>, <code>Int</code> and <code>Float64</code>. Many programming languages have types that depend on other types. For example Julia has the <code>Vector{T}</code> type representing vectors with elements of type <code>T</code>, e.g. <code>Vector{Int}</code> for vectors of type <code>Int</code>. With this you can write functions where the type of the output depends on the type of the input.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function singleton_vector(x::T)::Vector{T} where {T}
         return [x]
       end</code><code class="nohighlight hljs ansi" style="display:block;">singleton_vector (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(singleton_vector(5))</code><code class="nohighlight hljs ansi" style="display:block;">Vector{Int64}<span class="sgr90"> (alias for Array{Int64, 1})</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(singleton_vector(&quot;a&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">Vector{String}<span class="sgr90"> (alias for Array{String, 1})</span></code></pre><p>What dependent type theory adds to this is that it allows the type of the output to depend on the <strong>values</strong> of the input. For example in</p><pre><code class="language-lean-4 hljs">/--
  Axiom 2.4 (Different natural numbers have different successors).
  Compare with Mathlib&#39;s `Nat.succ_inj`.
-/
theorem Nat.succ_cancel {n m:Nat} (hnm: n++ = m++) : n = m := by
  injection hnm</code></pre><p>the output type <code>n + m</code> depends on the values of <code>n</code> and <code>m</code>. This type would be impossible to represent in Julia (and in the vast majority of programming languages).</p><p>This is critical for mathematics because it allows us to encode predicates like &quot;<span>$n = m$</span>&quot; or &quot;<span>$f$</span> is continuous&quot; as types.</p><h3 id="The-Axiomatic-Foundation"><a class="docs-heading-anchor" href="#The-Axiomatic-Foundation">The Axiomatic Foundation</a><a id="The-Axiomatic-Foundation-1"></a><a class="docs-heading-anchor-permalink" href="#The-Axiomatic-Foundation" title="Permalink"></a></h3><p>It is important to note that type theory is the language of the logic, but it is not the mathematics itself. Just like in pen-and-paper math, we still assume axioms.</p><p>Most formal libraries (like Lean&#39;s <code>Mathlib</code>) include axioms equivalent to ZFC (Zermelo-Fraenkel Set Theory with Choice), which is the standard foundation of modern mathematics. It would however be possible, in Lean, to write proofs based on a different axiomatic system.</p><h3 id="The-Lean-Kernel-vs.-The-Lean-Proof-Assistant"><a class="docs-heading-anchor" href="#The-Lean-Kernel-vs.-The-Lean-Proof-Assistant">The Lean Kernel vs. The Lean Proof Assistant</a><a id="The-Lean-Kernel-vs.-The-Lean-Proof-Assistant-1"></a><a class="docs-heading-anchor-permalink" href="#The-Lean-Kernel-vs.-The-Lean-Proof-Assistant" title="Permalink"></a></h3><p>One potential issue with formal proofs is <em>&quot;How do we know the proof software itself doesn&#39;t have a bug?&quot;</em></p><p>Systems like Lean are split into two distinct parts:</p><ol><li><strong>The Proof Assistant (The Elaborator/Tactics):</strong> This is the large, complex software layer (millions of lines of code) that helps you write the proof. It includes the VS Code interface, the &quot;tactics&quot; (commands like <code>induction</code> or <code>rewrite</code>), and automation. It is &quot;smart&quot; but potentially buggy.</li><li><strong>The Kernel (The Verifier):</strong> This is a very small, isolated piece of code (often just a few thousand lines). Its <strong>only</strong> job is to check the final proof object constructed by the assistant against the rules of the logic (Dependent Type Theory).</li></ol><p>Crucially, we do not need to trust the Proof Assistant. We only need to trust the Kernel.</p><p>If the &quot;smart&quot; automation in the Assistant makes a mistake or has a bug, it will generate a &quot;proof object&quot; that is nonsense. When the Kernel tries to check this object, it will reject it. This architecture drastically reduces the amount of the code you have to trust. You don&#39;t need to verify the entire Lean software suite, you only need to verify the small Kernel.</p><p>This isolation of a separate kernel is known as the &quot;de Bruijn criterion&quot;, see e.g. <a href="https://ammkrn.github.io/type_checking_in_lean4/whats_a_kernel.html">Type Checking in Lean 4</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../week-3-lab/">« Week 3 Lab: A simple computer-assisted proof (and VS Code)</a><a class="docs-footer-nextpage" href="../week-4-lecture-2/">Week 4 Lecture 2: TODO »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 9 February 2026 20:13">Monday 9 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
