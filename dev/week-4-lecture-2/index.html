<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Week 4 Lecture 2: Formal proofs · CAPCourseS26.jl</title><meta name="title" content="Week 4 Lecture 2: Formal proofs · CAPCourseS26.jl"/><meta property="og:title" content="Week 4 Lecture 2: Formal proofs · CAPCourseS26.jl"/><meta property="twitter:title" content="Week 4 Lecture 2: Formal proofs · CAPCourseS26.jl"/><meta name="description" content="Documentation for CAPCourseS26.jl."/><meta property="og:description" content="Documentation for CAPCourseS26.jl."/><meta property="twitter:description" content="Documentation for CAPCourseS26.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CAPCourseS26.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><span class="tocitem">Weeks</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox" checked/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Part 1: Introduction to computer-assisted proofs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../week-1-lecture-1/">Week 1 Lecture 1 - Introduction to computer-assisted proofs</a></li><li><a class="tocitem" href="../week-1-lab/">Week 1 Lab: Setup</a></li><li><a class="tocitem" href="../week-2-lecture-1/">Week 2 Lecture 1: Discrete problems</a></li><li><a class="tocitem" href="../week-2-lecture-2/">Week 2 Lecture 2: Integer arithmetic</a></li><li><a class="tocitem" href="../week-2-lab/">Week 2 Lab: Julia basics</a></li><li><a class="tocitem" href="../week-3-lecture-1/">Week 3 Lecture 1: Computer-assisted proofs for continuous problems</a></li><li><a class="tocitem" href="../week-3-lecture-2/">Week 3 Lecture 2: Computer-assisted proofs for continuous problems</a></li><li><a class="tocitem" href="../week-3-lab/">Week 3 Lab: A simple computer-assisted proof (and VS Code)</a></li><li><a class="tocitem" href="../week-4-lecture-1/">Week 4 Lecture 1: Formal proofs</a></li><li class="is-active"><a class="tocitem" href>Week 4 Lecture 2: Formal proofs</a><ul class="internal"><li><a class="tocitem" href="#What-is-the-point-of-formal-proofs?"><span>What is the point of formal proofs?</span></a></li><li><a class="tocitem" href="#What-is-a-formal-proof?"><span>What is a formal proof?</span></a></li></ul></li><li><a class="tocitem" href="../week-4-lab/">Week 4 Lab: Trying Lean</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Part 2: Introduction to rigorous numerics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../week-5-lecture-1/">Week 5 Lecture 1: Floating point numbers</a></li><li><a class="tocitem" href="../week-5-lecture-2/">Week 5 Lecture 2: Floating point numbers</a></li><li><a class="tocitem" href="../week-5-lab/">Week 5 Lab: Playing with floating points</a></li><li><a class="tocitem" href="../week-6-lecture-1/">Week 6 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-6-lecture-2/">Week 6 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-6-lab/">Week 6 Lab: TODO</a></li><li><a class="tocitem" href="../week-7-lecture-1/">Week 7 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-7-lecture-2/">Week 7 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-7-lab/">Week 7 Lab: TODO</a></li><li><a class="tocitem" href="../week-8-lecture-1/">Week 8 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-8-lecture-2/">Week 8 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-8-lab/">Week 8 Lab: TODO</a></li><li><a class="tocitem" href="../week-9-lecture-1/">Week 9 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-9-lecture-2/">Week 9 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-9-lab/">Week 9 Lab: TODO</a></li><li><a class="tocitem" href="../week-10-lecture-1/">Week 10 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-10-lecture-2/">Week 10 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-10-lab/">Week 10 Lab: TODO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Part 3: Computer-assisted proofs in practice</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../week-11-lecture-1/">Week 11 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-11-lecture-2/">Week 11 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-11-lab/">Week 11 Lab: TODO</a></li><li><a class="tocitem" href="../week-12-lecture-1/">Week 12 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-12-lecture-2/">Week 12 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-12-lab/">Week 12 Lab: TODO</a></li><li><a class="tocitem" href="../week-13-lecture-1/">Week 13 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-13-lecture-2/">Week 13 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-13-lab/">Week 13 Lab: TODO</a></li><li><a class="tocitem" href="../week-14-lecture-1/">Week 14 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-14-lecture-2/">Week 14 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-14-lab/">Week 14 Lab: TODO</a></li><li><a class="tocitem" href="../week-15-lecture-1/">Week 15 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-15-lecture-2/">Week 15 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-15-lab/">Week 15 Lab: TODO</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Weeks</a></li><li><a class="is-disabled">Part 1: Introduction to computer-assisted proofs</a></li><li class="is-active"><a href>Week 4 Lecture 2: Formal proofs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Week 4 Lecture 2: Formal proofs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Joel-Dahne/CAPCourseS26.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Joel-Dahne/CAPCourseS26.jl/blob/main/docs/src/week-4-lecture-2.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Week-4-Lecture-2:-Formal-proofs"><a class="docs-heading-anchor" href="#Week-4-Lecture-2:-Formal-proofs">Week 4 Lecture 2: Formal proofs</a><a id="Week-4-Lecture-2:-Formal-proofs-1"></a><a class="docs-heading-anchor-permalink" href="#Week-4-Lecture-2:-Formal-proofs" title="Permalink"></a></h1><p>In this lecture we continue our discussion of formal proofs, this time focusing on the foundations on which formal proofs are built. Let us however start by a more informal discussion about formal proofs.</p><h2 id="What-is-the-point-of-formal-proofs?"><a class="docs-heading-anchor" href="#What-is-the-point-of-formal-proofs?">What is the point of formal proofs?</a><a id="What-is-the-point-of-formal-proofs?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-the-point-of-formal-proofs?" title="Permalink"></a></h2><p>For computer-assisted proofs the goal is fairly clear, we want to be able to prove things that require computations that would not be feasible to perform by hand. For formal proofs the goals are perhaps less clear and to a large extent they depend on your point of view.</p><ul><li><strong>Correctness:</strong> This is in some sense the primary goal of formal proofs. Many published proofs contain errors, in most cases these errors are likely trivially fixable but not in all cases. Formal proofs could reduce (or to some extent even eliminate) such errors. On a large scale the area of mathematics does however seem to be relatively stable to such errors, see for example the discussions in this <a href="https://mathoverflow.net/questions/338607/why-doesnt-mathematics-collapse-even-though-humans-quite-often-make-mistakes-in">Mathoverflow post</a>.</li><li><strong>Mutating proofs:</strong> Writing a formal proof takes a lot longer than writing a pen and paper proof. Once a formal proof has been written it can however be much more straightforward to make small adjustments to the statements and the proofs. For example for fine-tuning constants. Lean can then tell you exactly where your previous arguments fail and where updates are needed. See for example this <a href="https://mathstodon.xyz/@tao/111360298114925842">Mathstodon post</a>.</li><li><strong>Automating routine parts:</strong> Some proofs require large routine calculations. Even if these calculations are simple, the sheer size could make them difficult to both write and referee. Having Lean automatically generate proofs for such parts could then save a lot of time. The Lean tools for automatically generating proofs are steadily improving, so even if some things are out of reach today they might not stay that way.</li><li><strong>Generative AI:</strong> Combining formal proofs with generative AI has the potential of letting mathematicians write informal proofs which can then be automatically formalized by the AI. This is possible to some extent today and the situation will likely improve. Formal proofs also seem to be a good ground for training AI using reinforcement learning.</li><li><strong>Large scale collaboration:</strong> Formal proofs reduces the need to trust proofs from coauthors. This could allow for more large scale collaboration that we are currently used to in mathematics.</li></ul><h2 id="What-is-a-formal-proof?"><a class="docs-heading-anchor" href="#What-is-a-formal-proof?">What is a formal proof?</a><a id="What-is-a-formal-proof?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-a-formal-proof?" title="Permalink"></a></h2><p>We have now seen some examples of what formal proofs could look like in practice. But how are these proofs actually checked? What foundations are these built on?</p><p>To understand this we will take a brief look at three core concepts: the correspondence between programs and proofs, the language used to express them, and the architecture that allows us to trust the software.</p><h3 id="The-Curry-Howard-Correspondence"><a class="docs-heading-anchor" href="#The-Curry-Howard-Correspondence">The Curry-Howard Correspondence</a><a id="The-Curry-Howard-Correspondence-1"></a><a class="docs-heading-anchor-permalink" href="#The-Curry-Howard-Correspondence" title="Permalink"></a></h3><p>The most fundamental concept to grasp is that in formal verification, there is a deep structural link between logic and programming. This is known as the <strong>Curry-Howard correspondence</strong> (or &quot;Propositions as Types&quot;).</p><p>In a standard programming language, you have <strong>types</strong> (like <code>int</code>, <code>string</code>, <code>List</code>) and <strong>values</strong> or <strong>programs</strong> that inhabit those types (like <code>5</code>, <code>&quot;hello&quot;</code>, <code>[1, 2]</code>).</p><p>In the world of formal proofs:</p><ul><li>A mathematical proposition (statement) is a Type.</li><li>A proof of that proposition is a Program (value) of that Type.</li></ul><p>Therefore, &quot;checking a proof&quot; is reduced to &quot;type-checking a program.&quot; If you write a function that claims to return an integer but actually returns a string, the compiler throws a type error. Similarly, if you write a proof that claims to prove Theorem X but contains a logical gap, the formal system throws a type error.</p><p>You can see this correspondence directly in Lean code (at least if you have some experience with functional programming languages). Take for example</p><pre><code class="language-lean-4 hljs">/--
  Axiom 2.4 (Different natural numbers have different successors).
  Compare with Mathlib&#39;s `Nat.succ_inj`.
-/
theorem Nat.succ_cancel {n m:Nat} (hnm: n++ = m++) : n = m := by
  injection hnm</code></pre><p>Here <code>Nat.succ_cancel</code> is a function that takes as input <code>n</code> and <code>m</code>, both of type <code>Nat</code> as well as <code>hnm</code> which is of type <code>n++ = m++</code> and returns a value of type <code>n = m</code>. In most programming languages treating <code>n = m</code> as a type doesn&#39;t make much sense, but in Lean it does. What comes after the <code>:=</code> part is what in a normal programming language would correspond to the implementation of the function.</p><p>A concrete example of this correspondence is implications. The mathematical statement that <span>$P \implies Q$</span> corresponds to a function that takes as input a value of type <code>P</code> and returns an output of type <code>Q</code>. The proof of the statement corresponds to the implementation of the function.</p><h3 id="Dependent-Type-Theory"><a class="docs-heading-anchor" href="#Dependent-Type-Theory">Dependent Type Theory</a><a id="Dependent-Type-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Dependent-Type-Theory" title="Permalink"></a></h3><p>To make the Curry-Howard correspondence work for complex mathematics one needs a type system that is <strong>much</strong> richer than what is found in standard languages like C or Julia or even Haskell. There are different approaches for this and different proof assistants use different systems. The system Lean is based on is called <strong>Dependent Type Theory</strong>.</p><p>Most standard programming languages have types like <code>Bool</code>, <code>Int</code> and <code>Float64</code>. Many programming languages have types that depend on other types. For example Julia has the <code>Vector{T}</code> type representing vectors with elements of type <code>T</code>, e.g. <code>Vector{Int}</code> for vectors of type <code>Int</code>. With this you can write functions where the type of the output depends on the type of the input.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function singleton_vector(x::T)::Vector{T} where {T}
         return [x]
       end</code><code class="nohighlight hljs ansi" style="display:block;">singleton_vector (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(singleton_vector(5))</code><code class="nohighlight hljs ansi" style="display:block;">Vector{Int64}<span class="sgr90"> (alias for Array{Int64, 1})</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(singleton_vector(&quot;a&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">Vector{String}<span class="sgr90"> (alias for Array{String, 1})</span></code></pre><p>What dependent type theory adds to this is that it allows the type of the output to depend on the <strong>values</strong> of the input. For example in</p><pre><code class="language-lean-4 hljs">/--
  Axiom 2.4 (Different natural numbers have different successors).
  Compare with Mathlib&#39;s `Nat.succ_inj`.
-/
theorem Nat.succ_cancel {n m:Nat} (hnm: n++ = m++) : n = m := by
  injection hnm</code></pre><p>the output type <code>n = m</code> depends on the values of <code>n</code> and <code>m</code>. This type would be impossible to represent in Julia (and in the vast majority of programming languages).</p><p>This is critical for mathematics because it allows us to encode predicates like &quot;<span>$n = m$</span>&quot; or &quot;<span>$f$</span> is continuous&quot; as types.</p><h3 id="The-Axiomatic-Foundation"><a class="docs-heading-anchor" href="#The-Axiomatic-Foundation">The Axiomatic Foundation</a><a id="The-Axiomatic-Foundation-1"></a><a class="docs-heading-anchor-permalink" href="#The-Axiomatic-Foundation" title="Permalink"></a></h3><p>It is important to note that type theory is the language of the logic, but it is not the mathematics itself. Just like in pen-and-paper math, we still assume axioms.</p><p>Most formal libraries (like Lean&#39;s <code>Mathlib</code>) include axioms equivalent to ZFC (Zermelo-Fraenkel Set Theory with Choice), which is the standard foundation of modern mathematics. It would however be possible, in Lean, to write proofs based on a different axiomatic system.</p><h3 id="The-Lean-Kernel-vs.-The-Lean-Proof-Assistant"><a class="docs-heading-anchor" href="#The-Lean-Kernel-vs.-The-Lean-Proof-Assistant">The Lean Kernel vs. The Lean Proof Assistant</a><a id="The-Lean-Kernel-vs.-The-Lean-Proof-Assistant-1"></a><a class="docs-heading-anchor-permalink" href="#The-Lean-Kernel-vs.-The-Lean-Proof-Assistant" title="Permalink"></a></h3><p>One potential issue with formal proofs is <em>&quot;How do we know the proof software itself doesn&#39;t have a bug?&quot;</em></p><p>Systems like Lean are split into two distinct parts:</p><ol><li><strong>The Proof Assistant (The Elaborator/Tactics):</strong> This is the large, complex software layer (millions of lines of code) that helps you write the proof. It includes the VS Code interface, the &quot;tactics&quot; (commands like <code>induction</code> or <code>rewrite</code>), and automation. It is &quot;smart&quot; but potentially buggy.</li><li><strong>The Kernel (The Verifier):</strong> This is a very small, isolated piece of code (often just a few thousand lines). Its <strong>only</strong> job is to check the final proof object constructed by the assistant against the rules of the logic (Dependent Type Theory).</li></ol><p>Crucially, we do not need to trust the Proof Assistant. We only need to trust the Kernel.</p><p>If the &quot;smart&quot; automation in the Assistant makes a mistake or has a bug, it will generate a &quot;proof object&quot; that is nonsense. When the Kernel tries to check this object, it will reject it. This architecture drastically reduces the amount of the code you have to trust. You don&#39;t need to verify the entire Lean software suite, you only need to verify the small Kernel.</p><p>This isolation of a separate kernel is known as the &quot;de Bruijn criterion&quot;, see e.g. <a href="https://ammkrn.github.io/type_checking_in_lean4/whats_a_kernel.html">Type Checking in Lean 4</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../week-4-lecture-1/">« Week 4 Lecture 1: Formal proofs</a><a class="docs-footer-nextpage" href="../week-4-lab/">Week 4 Lab: Trying Lean »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 20 February 2026 19:14">Friday 20 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
