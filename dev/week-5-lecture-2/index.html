<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Week 5 Lecture 2: Floating point numbers · CAPCourseS26.jl</title><meta name="title" content="Week 5 Lecture 2: Floating point numbers · CAPCourseS26.jl"/><meta property="og:title" content="Week 5 Lecture 2: Floating point numbers · CAPCourseS26.jl"/><meta property="twitter:title" content="Week 5 Lecture 2: Floating point numbers · CAPCourseS26.jl"/><meta name="description" content="Documentation for CAPCourseS26.jl."/><meta property="og:description" content="Documentation for CAPCourseS26.jl."/><meta property="twitter:description" content="Documentation for CAPCourseS26.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CAPCourseS26.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><span class="tocitem">Weeks</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Part 1: Introduction to computer-assisted proofs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../week-1-lecture-1/">Week 1 Lecture 1 - Introduction to computer-assisted proofs</a></li><li><a class="tocitem" href="../week-1-lab/">Week 1 Lab: Setup</a></li><li><a class="tocitem" href="../week-2-lecture-1/">Week 2 Lecture 1: Discrete problems</a></li><li><a class="tocitem" href="../week-2-lecture-2/">Week 2 Lecture 2: Integer arithmetic</a></li><li><a class="tocitem" href="../week-2-lab/">Week 2 Lab: Julia basics</a></li><li><a class="tocitem" href="../week-3-lecture-1/">Week 3 Lecture 1: Computer-assisted proofs for continuous problems</a></li><li><a class="tocitem" href="../week-3-lecture-2/">Week 3 Lecture 2: Computer-assisted proofs for continuous problems</a></li><li><a class="tocitem" href="../week-3-lab/">Week 3 Lab: A simple computer-assisted proof (and VS Code)</a></li><li><a class="tocitem" href="../week-4-lecture-1/">Week 4 Lecture 1: Formal proofs</a></li><li><a class="tocitem" href="../week-4-lecture-2/">Week 4 Lecture 2: Formal proofs</a></li><li><a class="tocitem" href="../week-4-lab/">Week 4 Lab: Trying Lean</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Part 2: Introduction to rigorous numerics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../week-5-lecture-1/">Week 5 Lecture 1: Floating point numbers</a></li><li class="is-active"><a class="tocitem" href>Week 5 Lecture 2: Floating point numbers</a><ul class="internal"><li><a class="tocitem" href="#Issues-with-floating-point-arithmetic"><span>Issues with floating point arithmetic</span></a></li><li><a class="tocitem" href="#Correctly-rounded-functions"><span>Correctly rounded functions</span></a></li><li><a class="tocitem" href="#Elementary-functions"><span>Elementary functions</span></a></li><li><a class="tocitem" href="#Libraries-for-correctly-rounded-functions"><span>Libraries for correctly rounded functions</span></a></li><li><a class="tocitem" href="#Why-this-doesn&#39;t-matter-too-much"><span>Why this doesn&#39;t matter too much</span></a></li></ul></li><li><a class="tocitem" href="../week-5-lab/">Week 5 Lab: TODO</a></li><li><a class="tocitem" href="../week-6-lecture-1/">Week 6 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-6-lecture-2/">Week 6 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-6-lab/">Week 6 Lab: TODO</a></li><li><a class="tocitem" href="../week-7-lecture-1/">Week 7 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-7-lecture-2/">Week 7 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-7-lab/">Week 7 Lab: TODO</a></li><li><a class="tocitem" href="../week-8-lecture-1/">Week 8 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-8-lecture-2/">Week 8 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-8-lab/">Week 8 Lab: TODO</a></li><li><a class="tocitem" href="../week-9-lecture-1/">Week 9 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-9-lecture-2/">Week 9 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-9-lab/">Week 9 Lab: TODO</a></li><li><a class="tocitem" href="../week-10-lecture-1/">Week 10 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-10-lecture-2/">Week 10 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-10-lab/">Week 10 Lab: TODO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Part 3: Computer-assisted proofs in practice</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../week-11-lecture-1/">Week 11 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-11-lecture-2/">Week 11 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-11-lab/">Week 11 Lab: TODO</a></li><li><a class="tocitem" href="../week-12-lecture-1/">Week 12 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-12-lecture-2/">Week 12 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-12-lab/">Week 12 Lab: TODO</a></li><li><a class="tocitem" href="../week-13-lecture-1/">Week 13 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-13-lecture-2/">Week 13 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-13-lab/">Week 13 Lab: TODO</a></li><li><a class="tocitem" href="../week-14-lecture-1/">Week 14 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-14-lecture-2/">Week 14 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-14-lab/">Week 14 Lab: TODO</a></li><li><a class="tocitem" href="../week-15-lecture-1/">Week 15 Lecture 1: TODO</a></li><li><a class="tocitem" href="../week-15-lecture-2/">Week 15 Lecture 2: TODO</a></li><li><a class="tocitem" href="../week-15-lab/">Week 15 Lab: TODO</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Weeks</a></li><li><a class="is-disabled">Part 2: Introduction to rigorous numerics</a></li><li class="is-active"><a href>Week 5 Lecture 2: Floating point numbers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Week 5 Lecture 2: Floating point numbers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Joel-Dahne/CAPCourseS26.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Joel-Dahne/CAPCourseS26.jl/blob/main/docs/src/week-5-lecture-2.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Week-5-Lecture-2:-Floating-point-numbers"><a class="docs-heading-anchor" href="#Week-5-Lecture-2:-Floating-point-numbers">Week 5 Lecture 2: Floating point numbers</a><a id="Week-5-Lecture-2:-Floating-point-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Week-5-Lecture-2:-Floating-point-numbers" title="Permalink"></a></h1><p>In this lecture, we will continue our study of floating point numbers. In particular we will talk about the evaluation of elementary functions and how this interacts with rounding.</p><h2 id="Issues-with-floating-point-arithmetic"><a class="docs-heading-anchor" href="#Issues-with-floating-point-arithmetic">Issues with floating point arithmetic</a><a id="Issues-with-floating-point-arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#Issues-with-floating-point-arithmetic" title="Permalink"></a></h2><p>Already in the last lecture we started talking about some of the issues that arise from floating point arithmetic not satisfying the usual properties we expect from arithmetic.</p><p>Most of these issues come from the operations not being associative. For example <code>(x + y) + z</code> and <code>x + (y + z)</code> are in general different floating point numbers. This non-associativity can make floating point arithmetic behave in a non-deterministic way. Each individual operation is of course deterministic; it computes the exact value of <span>$\bigcirc(x + y)$</span>, but in many cases the order these operations are performed is not always clear and in some cases not even deterministic.</p><div class="admonition is-info" id="Example:-@fastmath-and-summation-order-45a008db6da10dbb"><header class="admonition-header">Example: `@fastmath` and summation order<a class="admonition-anchor" href="#Example:-@fastmath-and-summation-order-45a008db6da10dbb" title="Permalink"></a></header><div class="admonition-body"><p>Let us consider the problem of computing a sum</p><p class="math-container">\[S = \sum_{n = 1}^{N} a_n.\]</p><p>in floating point arithmetic. We could implement this in Julia as</p><pre><code class="language-julia hljs">function strict_sum(as)
    S = zero(eltype(as))
    for a in as
        S += a # Strictly sequential addition
    end
    return S
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">strict_sum (generic function with 1 method)</code></pre><p>This will perform the sum from left to right. If we take <span>$a_n = 1 / 10$</span> (or rather <span>$a_n = \square(1 / 10)$</span>) and <span>$N = 10^6$</span>, this gives us</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; as = fill(1 / 10, 10^6);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; strict_sum(as)</code><code class="nohighlight hljs ansi" style="display:block;">100000.00000133288</code></pre><p>Let us next implement the same sum but put <code>@fastmath</code> before it, i.e.</p><pre><code class="language-julia hljs">function fast_sum(as)
    S = zero(eltype(as))
    @fastmath for a in as
        S += a # Compiler is allowed to reorder these additions
    end
    return S
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">fast_sum (generic function with 1 method)</code></pre><p>In this case we get</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fast_sum(as)</code><code class="nohighlight hljs ansi" style="display:block;">100000.00000008338</code></pre><p>which is slightly different from before! What happens here is that <code>@fastmath</code> tells the compiler that it doesn&#39;t have to follow the usual associativity rules for floating point arithmetic. It is free to reorder the operations if this will make the code faster. The exact result you get here will depend on your processor, as different orderings are faster depending on the precise architecture of the CPU. We can see that the performance differs quite a lot here!</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using BenchmarkTools</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @benchmark strict_sum($as) samples = 1000 evals = 1</code><code class="nohighlight hljs ansi" style="display:block;">BenchmarkTools.Trial: 1000 samples with 1 evaluation per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">925.539 μs</span></span> … <span class="sgr35">1.005 ms</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">935.849 μs             </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">937.163 μs</span></span> ± <span class="sgr32">5.415 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

   ▁               ▅▇█<span class="sgr34">▆</span>▃<span class="sgr32">▃</span>▂▁▁     ▂▂▂                          
  ███▆▆▅▇▅▁▄▄▄▅▁▁▄▄███<span class="sgr34">█</span>█<span class="sgr32">█</span>█████████████▇▆▆▇▄▇▁▆▆▄▆▅▅▆▅▄▄▁▄▅▅▁▄ █
  926 μs<span class="sgr90">       Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>       956 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">0 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">0</span>.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @benchmark fast_sum($as) samples = 1000 evals = 1</code><code class="nohighlight hljs ansi" style="display:block;">BenchmarkTools.Trial: 1000 samples with 1 evaluation per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">133.770 μs</span></span> … <span class="sgr35">351.647 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">139.060 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">141.322 μs</span></span> ± <span class="sgr32">  8.987 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

        ▄▇█<span class="sgr34">█</span>▃  <span class="sgr32"> </span>                                                
  ▂▂▄▅▇████<span class="sgr34">█</span>█▆▄<span class="sgr32">▃</span>▃▃▃▃▃▃▃▃▃▄▄▅▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▁▁▁▁▁▂▁▁▁▁▂ ▃
  134 μs<span class="sgr90">           Histogram: frequency by time</span>          169 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">0 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">0</span>.</code></pre></div></div><p>As the above example shows we can get slightly different results by changing the implementation, even if we mathematically are computing the same thing. Some of the things that can affect the results are:</p><ol><li>Your code</li><li>The code in the libraries that you are using</li><li>The compiler you are using</li><li>The processor you are using</li><li>The number of threads you are using</li></ol><p>The most common reason for changes in the result is that operations are reordered and the non-associativity hence means that we get a different result.</p><h2 id="Correctly-rounded-functions"><a class="docs-heading-anchor" href="#Correctly-rounded-functions">Correctly rounded functions</a><a id="Correctly-rounded-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Correctly-rounded-functions" title="Permalink"></a></h2><p>Consider a function <span>$f: \mathbb{R} \to \mathbb{R}$</span>. Given a rounding mode <span>$\bigcirc$</span> we define <span>$\bigcirc(f) : \mathbb{F}_p \to \mathbb{F}_p$</span> as</p><p class="math-container">\[\bigcirc(f)(x) = \bigcirc(f(x)).\]</p><p>We say that a floating point implementation of a function <span>$f$</span> is <strong>correctly rounded</strong> (according to the specified rounding mode) if it computes <span>$\bigcirc(f)$</span>.</p><p>This definition naturally generalizes to multivariable functions <span>$f: \mathbb{R}^n \to \mathbb{R}$</span>. The standard floating point arithmetic operations are examples of correctly rounded two variable functions.</p><p>The three variable function <span>$\operatorname{fma}$</span> (fused-multiply-add) is commonly used for floating points. It implements a correctly rounded version of <span>$x \cdot y + z$</span>. Evaluating this using standard floating point arithmetic would give you <span>$\bigcirc(\bigcirc(x \cdot y) + z)$</span>. The <span>$\operatorname{fma}$</span> function instead gives you <span>$\operatorname{fma}(x, y, z) = \bigcirc(x \cdot y + z)$</span>, it avoids rounding the intermediate result <span>$x \cdot y$</span>. Due to hardware support this operation can be both faster than performing the multiplication and addition separately and at the same time give better accuracy.</p><h2 id="Elementary-functions"><a class="docs-heading-anchor" href="#Elementary-functions">Elementary functions</a><a id="Elementary-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Elementary-functions" title="Permalink"></a></h2><p>The floating point functions we have looked at so far, <span>$+, -, \cdot, /$</span> and <span>$\operatorname{fma}$</span>, are primitive floating point functions in the sense that they are either implemented directly in hardware or computed directly through the <span>$x \cdot 2^y$</span> representation of floating points. The square root function and the reciprocal square root function (<span>$1 / \sqrt{x}$</span>) are two other examples of functions which are usually implemented directly in hardware, or where the implementation uses the <span>$x \cdot 2^y$</span> representation directly. Most other floating point functions are themselves implemented using floating point functions.</p><p>Ideally we want a floating point implementation to be correctly rounded, i.e. for a function <span>$f$</span> and a floating point number <span>$x$</span> we want it to return <span>$\bigcirc(f(x))$</span>. This, however, turns out to be too much to ask in many cases. The vast majority of functions implemented in floating points are not correctly rounded. We will look at</p><ol><li>How Julia computes <span>$\sin$</span></li><li>Libraries for correctly rounded elementary functions</li><li>Why correct rounding doesn&#39;t matter too much</li></ol><h3 id="Evaluating-\\sin"><a class="docs-heading-anchor" href="#Evaluating-\\sin">Evaluating <span>$\sin$</span></a><a id="Evaluating-\\sin-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluating-\\sin" title="Permalink"></a></h3><p>How does Julia compute <span>$\sin(x)$</span>? Finding out is surprisingly simple and the code is relatively easy to understand. You can find the code implementing <code>sin</code> by running <code>@less sin(0.0)</code>. This shows us the following function.</p><pre><code class="language-julia hljs">function sin(x::T) where T&lt;:Union{Float32, Float64}
    absx = abs(x)
    if absx &lt; T(pi)/4 #|x| ~&lt;= pi/4, no need for reduction
        if absx &lt; sqrt(eps(T))
            return x
        end
        return sin_kernel(x)
    elseif isnan(x)
        return x
    elseif isinf(x)
        sin_domain_error(x)
    end
    n, y = rem_pio2_kernel(x)
    n = n&amp;3
    if n == 0
        return sin_kernel(y)
    elseif n == 1
        return cos_kernel(y)
    elseif n == 2
        return -sin_kernel(y)
    else
        return -cos_kernel(y)
    end
end</code></pre><p>It checks some special cases, very small <code>x</code> (less than <code>sqrt(eps())</code>), <code>NaN</code> values and infinity values. Otherwise it does an argument reduction, reducing it to a value <code>y</code> in the range <span>$[-\pi/4, \pi/4]$</span> and information about which quadrant we are in. Depending on the quadrant it computes either <code>sin_kernel(y)</code> or <code>cos_kernel(y)</code>. Let us look closer at <code>sin_kernel</code> (<code>cos_kernel</code> is similar). The relevant code here is</p><pre><code class="language-julia hljs"># Coefficients in 13th order polynomial approximation on [0; π/4]
#     sin(x) ≈ x + S1*x³ + S2*x⁵ + S3*x⁷ + S4*x⁹ + S5*x¹¹ + S6*x¹³
# D for double, S for sin, number is the order of x-1
const DS1 = -1.66666666666666324348e-01
const DS2 = 8.33333333332248946124e-03
const DS3 = -1.98412698298579493134e-04
const DS4 = 2.75573137070700676789e-06
const DS5 = -2.50507602534068634195e-08
const DS6 = 1.58969099521155010221e-10

@inline function sin_kernel(y::Float64)
    y² =  y*y
    y⁴ =  y²*y²
    r  =  @horner(y², DS2, DS3, DS4) + y²*y⁴*@horner(y², DS5, DS6)
    y³ =  y²*y
    y+y³*(DS1+y²*r)
end</code></pre><p>To approximate <span>$\sin$</span> on <span>$[-\pi/4, \pi/4]$</span> it uses a degree 13 polynomial which is almost, but not quite, the Taylor expansion at zero. The slight adjustments to the coefficients are to minimize the maximum error on the interval, rather than the error close to zero. For evaluating the polynomial it doesn&#39;t directly use the form <code>y + S1*y³ + S2*y⁵ + S3*y⁷ + S4*y⁹ + S5*y¹¹ + S6*y¹³</code>, instead it uses a Horner like scheme. The <code>@horner</code> calls here correspond to</p><pre><code class="language-julia hljs">@horner(y², DS2, DS3, DS4) = DS2 + y² * (DS3 + y² * DS4)
@horner(y², DS5, DS6) = DS5 + y² * DS6</code></pre><p>Additionally, it uses <code>fma</code> for the computations. One can check that this corresponds to the polynomial we want to evaluate, but this choice of order reduces the rounding errors.</p><p>This implementation is not correctly rounded, though in the majority of cases it does return the correctly rounded result in practice. One example where it doesn&#39;t is</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = 0.17931446656123207</code><code class="nohighlight hljs ansi" style="display:block;">0.17931446656123207</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y1 = sin(x)</code><code class="nohighlight hljs ansi" style="display:block;">0.17835507366070658</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y2 = Float64(sin(BigFloat(x))) # Compute in higher precision and then round</code><code class="nohighlight hljs ansi" style="display:block;">0.17835507366070655</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y1 - y2</code><code class="nohighlight hljs ansi" style="display:block;">2.7755575615628914e-17</code></pre><h2 id="Libraries-for-correctly-rounded-functions"><a class="docs-heading-anchor" href="#Libraries-for-correctly-rounded-functions">Libraries for correctly rounded functions</a><a id="Libraries-for-correctly-rounded-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Libraries-for-correctly-rounded-functions" title="Permalink"></a></h2><p>Implementing correctly rounded functions is hard, even harder is implementing correctly rounded functions that are fast. One has to both control truncation errors coming from the finite expansions, as well as rounding errors when evaluating these expansions. In practice most libraries that implement correctly rounded functions internally make use of higher precision to be able to handle the rounding errors from evaluating the expansions. This then has to be combined with proofs for the truncation errors being sufficiently small. Two libraries that do this are</p><ol><li><a href="https://www.mpfr.org/">The GNU MPFR Library</a>: This implements arbitrary precision floating point arithmetic with full control over rounding. The <code>BigFloat</code> type in Julia uses this library under the hood.</li><li><a href="https://ens-lyon.hal.science/ensl-01529804v1">CR-LIBM</a>: This implements correctly rounded functions for <code>Float64</code>.</li></ol><h2 id="Why-this-doesn&#39;t-matter-too-much"><a class="docs-heading-anchor" href="#Why-this-doesn&#39;t-matter-too-much">Why this doesn&#39;t matter too much</a><a id="Why-this-doesn&#39;t-matter-too-much-1"></a><a class="docs-heading-anchor-permalink" href="#Why-this-doesn&#39;t-matter-too-much" title="Permalink"></a></h2><p>From a mathematical point of view, asking for correctly rounded elementary functions is natural. In practice, it is however not that important. Even if all the functions you are using are correctly rounded, you will still be combining the results from these functions and introduce rounding errors along the way.</p><p>At a fundamental level, the issue is that functions being correctly rounded &quot;doesn&#39;t compose&quot;. If we have two functions <span>$f$</span> and <span>$g$</span> and manage to implement correctly rounded versions of these, i.e.<span>$\bigcirc(f)$</span> and <span>$\bigcirc(g)$</span>, then computing <span>$\bigcirc(f)(\bigcirc(g)(x))$</span> corresponds to <span>$\bigcirc(f(\bigcirc(g(x))))$</span> which in general is not the same as <span>$\bigcirc(f(g(x)))$</span>.</p><p>Solving this composition problem is one of the things that interval arithmetic will allow us to do. It will not allow us to get correctly rounded results, but it will allow us to get results where we have control over the error.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../week-5-lecture-1/">« Week 5 Lecture 1: Floating point numbers</a><a class="docs-footer-nextpage" href="../week-5-lab/">Week 5 Lab: TODO »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 18 February 2026 19:01">Wednesday 18 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
